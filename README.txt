I. Design
    A. Huffman Encoding
        1. Algorithm Theory:
            a. Algorithm used to compress data without losing information. i.e. lossless compression
            b. Begin by counting the frequency of characters in the input data.
            c. Create a binary tree where each leaf node represents a character and the path from the root to the leaf corresponds to the binary code of the character.
            d. Once tree is completed, traverse the tree and assign binary code to each character. Traversing left is a '0' and right is a '1'.
            e. Once Huffman tree is constructed, input data is encoded by replacing each character with its correspoding Huffman code.
            f. The Huffman tree is stored first and the encoded information is followed.

        2. Trade-offs:
            a. Compression process can get computationally intensive for large datasets.
            b. Requires knowledge of the entire input data before constructing the tree.

    B. LZW Encoding
        1. Algorithm Theory:
            a. Algorithm used to compress data without losing information. i.e. lossless compression
            b. Build a dictionary of strings encountered in the input data and replace recurring strings with shorter codes.
            c. The dictionary begins with single-character data for all possible characters. (i.e All ASCII characters)
            d. Scan the input data from left to right, building substrings and checking if they are already present in the dictionary.
            e. During the process, encoded output is generated by replacing substrings with their corresponding codes from the dictionary.

        2. Trade-off:
            a. Compression is dependant on the dictionary size. Larger dictionary can capture more patterns, but may use more memory for storage.
            
    C. Tar Archive
        1. Algorithm Theory:
            a. Bundling multiple files into a single file.
            b. Archived file contains information about the bundled file in a structured format.
            c. Archived file contains the following information in order:
                1. 4 byte integer ending in 10011, or dec 19.  That 19 represents the length of the filename
                2. A separator character "11111111"
                3. The filename, a string.
                4. Another separator character "11111111"
                5. A 64-bit number (Java long) ending in 00001100, decimal 12, the length of the file
                6. Another separator character "11111111"
                7. Contents of the file

II. Installation
    A. Clone Repository: git clone
    B. Navigate into project directory: cd Project_File_Compression_yxk19a
    C. Make sure you are in the root project directory: pwd
        1. "pwd" should result in something like /Users/blee/Desktop/Project_File_Compression
    D. Make sure that the following Java programs and classes are on the same directory as SchubsL.java, SchubsH.java, SchubsArc.java, Deschubs.java
        1. BinaryOut.java, BinaryIn.java
        2. BinaryStdIn.java, BinaryStdOut.java
        3. StdIn.java, StdOut.java
        4. Queue.java, MinPQ.java
        5. TST.java

III. Test Instructions
    A. Make sure you are in the same level as the "pom.xml" file
    B. run: mvn compile // mvn Test

IV. Run Examples
    A. Make sure you are in the root project directory
    B. Make sure all java programs are compiled: javac example.java
    C. Run Programs
        1. Huffman Compression: java SchubsH <filename>
        2. LZW Compression: java SchubsL <filename>
        3. Archive using Tar: java SchubsArc archive-name <file1name> <file2name> ...
        4. Decompress files: java Deschubs <filename.ll|hh|hz>